// Code generated by "setter -type=bool"; DO NOT EDIT; setter: go get github.com/baza-winner/bwcore/setter

package bwset

import (
	bwjson "github.com/baza-winner/bwcore/bwjson"
	"sort"
	"strconv"
)

// BoolSet - множество значений типа bool с поддержкой интерфейсов Stringer и github.com/baza-winner/bwcore/bwjson.Jsonable
type BoolSet map[bool]struct{}

// BoolSetFrom - конструктор BoolSet
func BoolSetFrom(kk ...bool) BoolSet {
	result := BoolSet{}
	for _, k := range kk {
		result[k] = struct{}{}
	}
	return result
}

// BoolSetFromSlice - конструктор BoolSet
func BoolSetFromSlice(kk []bool) BoolSet {
	result := BoolSet{}
	for _, k := range kk {
		result[k] = struct{}{}
	}
	return result
}

// BoolSetFromSet - конструктор BoolSet
func BoolSetFromSet(s BoolSet) BoolSet {
	result := BoolSet{}
	for k, _ := range s {
		result[k] = struct{}{}
	}
	return result
}

// Copy - создает независимую копию
func (v BoolSet) Copy() BoolSet {
	return BoolSetFromSet(v)
}

// ToSlice - возвращает в виде []bool
func (v BoolSet) ToSlice() []bool {
	result := []bool{}
	for k, _ := range v {
		result = append(result, k)
	}
	return result
}

// String - поддержка интерфейса Stringer
func (v BoolSet) String() string {
	return bwjson.PrettyJsonOf(v)
}

// GetDataForJson - поддержка интерфейса bwjson.Jsonable
func (v BoolSet) GetDataForJson() interface{} {
	result := []interface{}{}
	for k, _ := range v {
		result = append(result, strconv.FormatBool(k))
	}
	return result
}

// ToSliceOfStrings - возвращает []string строковых представлений элементов множества
func (v BoolSet) ToSliceOfStrings() []string {
	result := []string{}
	for k, _ := range v {
		result = append(result, strconv.FormatBool(k))
	}
	sort.Strings(result)
	return result
}

// Has - возвращает true, если множество содержит заданный элемент, в противном случае - false
func (v BoolSet) Has(k bool) bool {
	_, ok := v[k]
	return ok
}

/*
HasAny - возвращает true, если множество содержит хотя бы один из заданныx элементов, в противном случае - false.
HasAny(<пустой набор/множесто>) возвращает false
*/
func (v BoolSet) HasAny(kk ...bool) bool {
	for _, k := range kk {
		if _, ok := v[k]; ok {
			return true
		}
	}
	return false
}

/*
HasAnyOfSlice - возвращает true, если множество содержит хотя бы один из заданныx элементов, в противном случае - false.
HasAny(<пустой набор/множесто>) возвращает false
*/
func (v BoolSet) HasAnyOfSlice(kk []bool) bool {
	for _, k := range kk {
		if _, ok := v[k]; ok {
			return true
		}
	}
	return false
}

/*
HasAnyOfSet - возвращает true, если множество содержит хотя бы один из заданныx элементов, в противном случае - false.
HasAny(<пустой набор/множесто>) возвращает false
*/
func (v BoolSet) HasAnyOfSet(s BoolSet) bool {
	for k, _ := range s {
		if _, ok := v[k]; ok {
			return true
		}
	}
	return false
}

/*
HasEach - возвращает true, если множество содержит все заданные элементы, в противном случае - false.
HasEach(<пустой набор/множесто>) возвращает true
*/
func (v BoolSet) HasEach(kk ...bool) bool {
	for _, k := range kk {
		if _, ok := v[k]; !ok {
			return false
		}
	}
	return true
}

/*
HasEachOfSlice - возвращает true, если множество содержит все заданные элементы, в противном случае - false.
HasEach(<пустой набор/множесто>) возвращает true
*/
func (v BoolSet) HasEachOfSlice(kk []bool) bool {
	for _, k := range kk {
		if _, ok := v[k]; !ok {
			return false
		}
	}
	return true
}

/*
HasEachOfSet - возвращает true, если множество содержит все заданные элементы, в противном случае - false.
HasEach(<пустой набор/множесто>) возвращает true
*/
func (v BoolSet) HasEachOfSet(s BoolSet) bool {
	for k, _ := range s {
		if _, ok := v[k]; !ok {
			return false
		}
	}
	return true
}

// Add - добавляет элементы в множество v
func (v BoolSet) Add(kk ...bool) {
	for _, k := range kk {
		v[k] = struct{}{}
	}
}

func (v BoolSet) _AddTestHelper(kk ...bool) BoolSet {
	result := v.Copy()
	result.Add(kk...)
	return result
}

// AddSlice - добавляет элементы в множество v
func (v BoolSet) AddSlice(kk []bool) {
	for _, k := range kk {
		v[k] = struct{}{}
	}
}

func (v BoolSet) _AddSliceTestHelper(kk []bool) BoolSet {
	result := v.Copy()
	result.AddSlice(kk)
	return result
}

// AddSet - добавляет элементы в множество v
func (v BoolSet) AddSet(s BoolSet) {
	for k, _ := range s {
		v[k] = struct{}{}
	}
}

func (v BoolSet) _AddSetTestHelper(s BoolSet) BoolSet {
	result := v.Copy()
	result.AddSet(s)
	return result
}

// Del - удаляет элементы из множествa v
func (v BoolSet) Del(kk ...bool) {
	for _, k := range kk {
		delete(v, k)
	}
}

func (v BoolSet) _DelTestHelper(kk ...bool) BoolSet {
	result := v.Copy()
	result.Del(kk...)
	return result
}

// DelSlice - удаляет элементы из множествa v
func (v BoolSet) DelSlice(kk []bool) {
	for _, k := range kk {
		delete(v, k)
	}
}

func (v BoolSet) _DelSliceTestHelper(kk []bool) BoolSet {
	result := v.Copy()
	result.DelSlice(kk)
	return result
}

// DelSet - удаляет элементы из множествa v
func (v BoolSet) DelSet(s BoolSet) {
	for k, _ := range s {
		delete(v, k)
	}
}

func (v BoolSet) _DelSetTestHelper(s BoolSet) BoolSet {
	result := v.Copy()
	result.DelSet(s)
	return result
}

// Union - возвращает результат объединения двух множеств. Исходные множества остаются без изменений
func (v BoolSet) Union(s BoolSet) BoolSet {
	result := v.Copy()
	result.AddSet(s)
	return result
}

// Intersect - возвращает результат пересечения двух множеств. Исходные множества остаются без изменений
func (v BoolSet) Intersect(s BoolSet) BoolSet {
	result := BoolSet{}
	for k, _ := range v {
		if _, ok := s[k]; ok {
			result[k] = struct{}{}
		}
	}
	return result
}

// Subtract - возвращает результат вычитания двух множеств. Исходные множества остаются без изменений
func (v BoolSet) Subtract(s BoolSet) BoolSet {
	result := BoolSet{}
	for k, _ := range v {
		if _, ok := s[k]; !ok {
			result[k] = struct{}{}
		}
	}
	return result
}
