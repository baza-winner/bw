// logic

// primary
begin 0
expectSpaceOrQwItemOrDelimiter
expectSpaceOrMapKey
expectEndOfQwItem
expectContentOf
expectWord
expectEscapedContentOf
expectRocket

// secondary
orArrayItemSeparator 0
orMapKeySeparator
orUnderscoreOrDot
orUnderscore
stringToken
keyToken
orSpace

// type
string 0
qw
qwItem
number
word
key
map
array
string

finish { /* some */
  (stack.-1.type [$string $qwItem]:
    stack.-1 ( .string > .result )
  )
  (stack.-1.type $number:
    stack.-1 ( .string | ParseNumber >.result )
  )
  (stack.-1.type $word:
    {
      (stack.-1.string "true":
        true > stack.-1.result
      )
      (stack.-1.string "false" :
        false > stack.-1.result
      )
      (stack.-1.string <nil null>)
      (stack.-1.string [ "Bool" <String Int Number Map Array> "ArrayOf"]:
        stack.-1 (.string > .result)
      )
      (stack.-1.string "qw" :
        PullRune
        {
          (OpenBraces Punct Symbol:
            $expectSpaceOrQwItemOrDelimiter > primary nil > secondary
            stack.-1 (
              $qw > .type
              Array > .result
              rune |PairBrace> .delimiter
            )
          )
          (: Unexpected rune)
        }
        true > skipPostProcess
      )
      (: Unexpected stack.-1 )
    }
  )
}

postProcess {
  (stack (.# 0) )
  (stack.# 1: $end > primary $orSpace > secondary )
  (:
    {
      (stack.-2.type $qw :
        stack (.-1.result >> .-2.result)
        $expectSpaceOrQwItemOrDelimiter > primary nil > secondary
      )
      (stack.-2.type $array :
        {
          (stack.-1.type $qw: stack (.-1.result >>> .-2.result) )
          (: stack (.-1.result >> .-2.result) )
        }
        $begin > primary $orArrayItemSeparator > secondary
      )
      (stack.-2.type $map:{
          ( stack.-1.type $key:
            stack ( .-1.string > .-2.key )
            $begin> primary $orMapKeySeparator > secondary
          )
          (:
            stack ( .-1.result > .-2.result.{.-2.key} )
            $expectSpaceOrMapKey > primary $orMapValueSeparator > secondary
          )
      })
      (: Unexpected stack.-1 )
    }
    stack | ButLast > stack
  )
}

primaryState {
  (primary $end: {
    (EOF: $end > primary nil > secondary )
    (Space)
    (:Unexpected rune)
  })
  (primary $expectRocket: {
     ('>': $begin > primary nil > secondary )
     (:Unexpected rune)
  })
  (primary $expectWord: {
    (Letter Digit: rune >> stack.-1.string )
    (: PushRune true > needFinish )
  })
  (primary $expectSpaceOrQwItemOrDelimiter: {
    (EOF: Unexpected rune)
    (Space)
    (rune stack.-1.delimiter: true > needFinish )
    (:
      Item
       | "qwItem" > type
       | stack.-1.delimiter > delimiter
       | rune >> string
      >>> stack
      $expectEndOfQwItem > primary nil > secondary
    )
  })
  (primary $expectEndOfQwItem: {
    (EOF: Unexpected rune)
    (Space rune stack.-1.delimiter: PushRune true > needFinish)
    (: rune >> stack.-1.string )
  })
  (primary $expectContentOf: {
    (EOF: Unexpected rune)
    (rune stack.-1.delimiter: true > needFinish)
    ('\\': $expectEscapedContentOf > primary)
    (: rune >> stack.-1.string )
  })
  (primary $expectDigit: {
    (Digit secondary nil:
      rune >> stack.-1.string
      $orUnderscoreOrDot > secondary
    )
    ('.' secondary $orUnderscoreOrDot:
      rune >> stack.-1.string
      $orUnderscore > secondary
    )
    ('_' Digit secondary [$orUnderscoreOrDot $orUnderscore]:
      rune >> stack.-1.string
    )
    ( secondary nil: Unexpected rune )
    (: PushRune true > needFinish )
  })
  (primary $expectSpaceOrMapKey: {
    (Space)
    (Letter:
      Item
      | $key > type
      | rune >> string
      >>> stack
      $expectWord > primary nil > secondary
    )
    ( '"' '\'':
      Item
      | $key > type
      | rune > delimiter
      >>> stack
      $expectContentOf > primary $keyToken > secondary
    )
    ( stack ( .-1 (rune .delimiter .type $map) ) :
    // (  rune stack.-1.delimiter stack.-1.type $map :
      true > needFinish
    )
  })
  (primary $expectEscapedContentOf: {
    ('"' '\'' '\\':
      rune >> stack.-1.string $expectContentOf > primary
    )
    (stack.-1.delimiter '"': {
      ('a' 'b' 'f' 'n' 'r' 't' 'v': rune | Escape > stack.-1.string )
      (: Unexpected rune)
    })
  })
  ( primary $begin: {
    (EOF stack.# 0:
      $end > primary nil > secondary
    )
    (EOF: Unexpected rune)
    ('=' secondary $orMapKeySeparator:
      $expectRocket > primary nil > secondary
    )
    (':' secondary $orMapKeySeparator:
      $begin> primary nil > secondary
    )
    (Space)
    ('{':
      Item
      | Map > result
      | $map > type
      >>> stack
      '}' > stack.-1.delimiter
      $expectSpaceOrMapKey > primary nil > secondary
    )
    ('<':
      Item
      | Array > result
      | $qw > type
      | '>' > delimiter
      >>> stack
      $expectSpaceOrQwItemOrDelimiter > primary nil > secondary
    )
    ('[':
      Item
      | Array > result
      | $array > type
      | ']' > delimiter
      >>> stack

      $begin> primary nil > secondary
    )
    ( stack.-1.type $array rune stack.-1.delimiter:
      true > needFinish
    )
    ('-' '+':
      Item
      | $number > type
      | rune >> string
      >>> stack
      $expectDigit > primary nil > secondary
    )
    (Digit:
      Item
      | $number > type
      | rune >> string
      >>> stack
      $expectDigit > primary $orUnderscoreOrDot > secondary
    )
    ('"' '\'':
      Item
      | $string > type
      | rune > delimiter
      >>> stack
      $expectContentOf > primary $stringToken > secondary
    )
    (Letter:
      Item
      | $word > type
      | rune >> string
      >>> stack
      $expectWord > primary nil > secondary
    )
    (:Unexpected rune)
  })
  (:Unexpected)
}

main {
  (:
    PullRune
    {(primary nil: $begin> primary)}
    false > needFinish
    { $primaryState }
    {(needFinish true:
      false > skipPostProcess
      { $finish }
      {(skipPostProcess false: {$postProcess})}
    )}
  )
}
