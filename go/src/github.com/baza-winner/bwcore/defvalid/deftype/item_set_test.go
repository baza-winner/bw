// Code generated by "bwsetter -type=Item"; DO NOT EDIT; bwsetter: go get -type=Item -set=Set -omitprefix -test%!(EXTRA string=github.com/baza-winner/bwcore/bwsetter)

package deftype

import (
	"encoding/json"
	bwjson "github.com/baza-winner/bwcore/bwjson"
	bwtesting "github.com/baza-winner/bwcore/bwtesting"
	"testing"
)

func TestSet(t *testing.T) {
	bwtesting.BwRunTests(t, From, map[string]bwtesting.Case{"From": {
		In: []interface{}{_SetTestItemA, _SetTestItemB},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, FromSlice, map[string]bwtesting.Case{"FromSlice": {
		In: []interface{}{[]Item{_SetTestItemA, _SetTestItemB}},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, FromSet, map[string]bwtesting.Case{"FromSet": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Set.Copy, map[string]bwtesting.Case{"Set.Copy": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Set.ToSlice, map[string]bwtesting.Case{"Set.ToSlice": {
		In:  []interface{}{Set{_SetTestItemA: struct{}{}}},
		Out: []interface{}{[]Item{_SetTestItemA}},
	}})
	bwtesting.BwRunTests(t, _SetToSliceTestHelper, map[string]bwtesting.Case{"_SetToSliceTestHelper": {
		In:  []interface{}{[]Item{_SetTestItemB, _SetTestItemA}},
		Out: []interface{}{[]Item{_SetTestItemA, _SetTestItemB}},
	}})
	bwtesting.BwRunTests(t, Set.String, map[string]bwtesting.Case{"Set.String": {
		In:  []interface{}{Set{_SetTestItemA: struct{}{}}},
		Out: []interface{}{bwjson.Pretty([]Item{_SetTestItemA})},
	}})
	bwtesting.BwRunTests(t, Set.MarshalJSON, map[string]bwtesting.Case{"Set.MarshalJSON": {
		In: []interface{}{Set{_SetTestItemA: struct{}{}}},
		Out: []interface{}{(func() []byte {
			result, _ := json.Marshal([]interface{}{_SetTestItemA})
			return result
		})(), nil},
	}})
	bwtesting.BwRunTests(t, Set.ToSliceOfStrings, map[string]bwtesting.Case{"Set.ToSliceOfStrings": {
		In:  []interface{}{Set{_SetTestItemA: struct{}{}}},
		Out: []interface{}{[]string{_SetTestItemA.String()}},
	}})
	bwtesting.BwRunTests(t, Set.Has, map[string]bwtesting.Case{
		"Set.Has: false": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, _SetTestItemB},
			Out: []interface{}{false},
		},
		"Set.Has: true": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, _SetTestItemA},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set.HasAny, map[string]bwtesting.Case{
		"Set.HasAny: empty": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}},
			Out: []interface{}{false},
		},
		"Set.HasAny: false": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, _SetTestItemB},
			Out: []interface{}{false},
		},
		"Set.HasAny: true": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, _SetTestItemA, _SetTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set.HasAnyOfSlice, map[string]bwtesting.Case{
		"Set.HasAnyOfSlice: empty": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, []Item{}},
			Out: []interface{}{false},
		},
		"Set.HasAnyOfSlice: false": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, []Item{_SetTestItemB}},
			Out: []interface{}{false},
		},
		"Set.HasAnyOfSlice: true": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, []Item{_SetTestItemA, _SetTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set.HasAnyOfSet, map[string]bwtesting.Case{
		"Set.HasAnyOfSet: empty": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, Set{}},
			Out: []interface{}{false},
		},
		"Set.HasAnyOfSet: false": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, Set{_SetTestItemB: struct{}{}}},
			Out: []interface{}{false},
		},
		"Set.HasAnyOfSet: true": {
			In: []interface{}{Set{_SetTestItemA: struct{}{}}, Set{
				_SetTestItemA: struct{}{},
				_SetTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set.HasEach, map[string]bwtesting.Case{
		"Set.HasEach: empty": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}},
			Out: []interface{}{true},
		},
		"Set.HasEach: false": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, _SetTestItemA, _SetTestItemB},
			Out: []interface{}{false},
		},
		"Set.HasEach: true": {
			In: []interface{}{Set{
				_SetTestItemA: struct{}{},
				_SetTestItemB: struct{}{},
			}, _SetTestItemA, _SetTestItemB},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set.HasEachOfSlice, map[string]bwtesting.Case{
		"Set.HasEachOfSlice: empty": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, []Item{}},
			Out: []interface{}{true},
		},
		"Set.HasEachOfSlice: false": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, []Item{_SetTestItemA, _SetTestItemB}},
			Out: []interface{}{false},
		},
		"Set.HasEachOfSlice: true": {
			In: []interface{}{Set{
				_SetTestItemA: struct{}{},
				_SetTestItemB: struct{}{},
			}, []Item{_SetTestItemA, _SetTestItemB}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set.HasEachOfSet, map[string]bwtesting.Case{
		"Set.HasEachOfSet: empty": {
			In:  []interface{}{Set{_SetTestItemA: struct{}{}}, Set{}},
			Out: []interface{}{true},
		},
		"Set.HasEachOfSet: false": {
			In: []interface{}{Set{_SetTestItemA: struct{}{}}, Set{
				_SetTestItemA: struct{}{},
				_SetTestItemB: struct{}{},
			}},
			Out: []interface{}{false},
		},
		"Set.HasEachOfSet: true": {
			In: []interface{}{Set{
				_SetTestItemA: struct{}{},
				_SetTestItemB: struct{}{},
			}, Set{
				_SetTestItemA: struct{}{},
				_SetTestItemB: struct{}{},
			}},
			Out: []interface{}{true},
		},
	})
	bwtesting.BwRunTests(t, Set._AddTestHelper, map[string]bwtesting.Case{"Set.Add": {
		In: []interface{}{Set{_SetTestItemA: struct{}{}}, _SetTestItemB},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Set._AddSliceTestHelper, map[string]bwtesting.Case{"Set.AddSlice": {
		In: []interface{}{Set{_SetTestItemA: struct{}{}}, []Item{_SetTestItemB}},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Set._AddSetTestHelper, map[string]bwtesting.Case{"Set.AddSet": {
		In: []interface{}{Set{_SetTestItemA: struct{}{}}, Set{_SetTestItemB: struct{}{}}},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Set._DelTestHelper, map[string]bwtesting.Case{"Set.Del": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}, _SetTestItemB},
		Out: []interface{}{Set{_SetTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Set._DelSliceTestHelper, map[string]bwtesting.Case{"Set.DelSlice": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}, []Item{_SetTestItemB}},
		Out: []interface{}{Set{_SetTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Set._DelSetTestHelper, map[string]bwtesting.Case{"Set.DelSet": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}, Set{_SetTestItemB: struct{}{}}},
		Out: []interface{}{Set{_SetTestItemA: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Set.Union, map[string]bwtesting.Case{"Set.Union": {
		In: []interface{}{Set{_SetTestItemA: struct{}{}}, Set{_SetTestItemB: struct{}{}}},
		Out: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}},
	}})
	bwtesting.BwRunTests(t, Set.Intersect, map[string]bwtesting.Case{"Set.Intersect": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}, Set{_SetTestItemB: struct{}{}}},
		Out: []interface{}{Set{_SetTestItemB: struct{}{}}},
	}})
	bwtesting.BwRunTests(t, Set.Subtract, map[string]bwtesting.Case{"Set.Subtract": {
		In: []interface{}{Set{
			_SetTestItemA: struct{}{},
			_SetTestItemB: struct{}{},
		}, Set{_SetTestItemB: struct{}{}}},
		Out: []interface{}{Set{_SetTestItemA: struct{}{}}},
	}})
}
